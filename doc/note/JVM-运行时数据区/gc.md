# 运行时数据区
HotSpot VM在执行Java程序的过程中，为了满足
各种不同需求会将内存划分为若干个不同的运行时
数据区。主要的数据区有堆空间、栈空间和直接内存。
![JVM-运行时数据区.png](../../images/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

## 栈空间
栈空间是线程私有的
 - 虚拟机栈
   - Java栈可以分为解释栈和编译栈，而栈是由
     一个个栈帧组成的，每个栈帧中都拥有局部变量表和
     操作数栈等信息。 
   - Java栈中保存的主要内容是栈帧，每次函数调用
     都会有一个对应的栈帧被压入Java栈，每次函数调用
     结束后都会有一个栈帧被弹出。Java方法有return字
     节码和抛出异常两种返回方式，不管哪种返回方式都
     会导致栈帧被弹出。
   - 与程序计数器一样，Java虚拟机栈也是线程私有的，
     而且随着线程的创建而创建，随着线程的结束而死亡。
 - 本地方法栈
   - 本地方法栈其实就是C/C++栈，某个线程在执行过
     程中可能会调用Java的native方法，也可能会调用
     HotSpot VM本身用C/C++语言编写的函数，不过这二者
     并没有本质区别，因为native方法最终还是由C/C++语
     言实现的。
   - 本地方法栈同样随着线程的创建而创建，随着线程的结束而死亡。 
 - 程序计数器
   - 程序计数器是线程私有的一块内存区域，各线程
     之间的程序计数器不会相互影响。程序计数器对于
     HotSpot VM的解释执行非常重要。解释器通过改变这
     个计数器的值来选取下一条需要执行的字节码指令，
     分支、循环、跳转、异常处理、线程恢复等功能都需
     要依赖这个计数器来完成。
   - 程序计数器的生命周期随着线程的创建而创
     建，随着线程的结束而死亡。

## 堆空间
Java堆是所有线程共享的一块内存区域，该区域
会存放几乎所有的对象及数组，由于对象或数组会不
断地创建和死亡，所以这是Java垃圾收集器收集的主
要区域。

堆空间
 - Java将堆空间划分为年轻代堆空间和老年代堆空
   间，这样就可以使用分代垃圾收集算法。
 - 年轻代堆空间，将其划分为Eden区、
   From Survivor区和To Survivor区。

## 直接内存
 - 直接内存并不是Java虚拟机运行时数据区的一部
分，也不是Java虚拟机规范中定义的内存区域。
 - 在OpenJDK 8中，元空间使用的就是直接内存。与之前
   OpenJDK版本使用永久代很大的不同是，如果不指定内
   存大小的话，随着更多类的创建，虚拟机会耗尽所有
   可用的系统内存。
 - JDK 1.4中新加入的NIO类引入了一种基于
   通道（Channel）与缓存区（Buffer）的I/O方式，它
   可以使用Native函数库直接分配堆外内存。
 - 本机直接内存的分配不会受到Java堆的限制，但
   既然是内存，就会受到本机总内存及处理器寻址空间
   的限制。

## 元空间
从OpenJDK 8开始，使用元空间（Metaspace）替换了之前版本中使用的永久代（PermGen）。

永久代主要存放以下数据：
 - 类的元数据信息，如常量池、方法等；
 - 类的静态信息；
 - 字符串驻留。

其中相关的数据已经被转移到元空间或堆中了，如字
符串驻留和类的静态信息被转移到了堆中，而类的元
数据信息被转移到了元空间中，因此前面介绍的保存
类的元数据信息的Klass、Method、ConstMethod与
ConstantPool等实例都是在元空间上分配内存。

Metaspace区域位于堆外，因此它的内存大小取决
于系统内存而不是堆大小，我们可以指定
MaxMetaspaceSize参数来限定它的最大内存。

Metaspace用来存放类的元数据信息，元数据信息
用于记录一个Java类在JVM中的信息，包括以下几类信息：
 - Klass结构：可以理解为类在HotSpot VM内部的对
等表示。
 - Method与ConstMethod：保存Java方法的相关信
息，包括方法的字节码、局部变量表、异常表和参
数信息等。
- ConstantPool：保存常量池信息。
- 注解：提供与程序有关的元数据信息，但是这些信
息并不属于程序本身。
- 方法计数器：记录方法被执行的次数，用来辅助
JIT决策。

### 元空间的基本结构
![元空间的基本结构.png](../../images/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

在元空间中会保存一个VirtualSpace的单链表，
每个链表的节点为VirtualSpaceNode，单链表之间通
过VirtualSpaceNode类中定义的next属性连接。每个
VirtualSpaceNode节点在实际使用过程中会分出4种不
同大小的Metachunk块，主要是增加灵活分配的同时便
于复用，方便管理。

    1、为什么一个类加载器申请Metaspace空间时会得到一个比要求的内存大得多的内存块呢？
 - 因为前面说了，要从全局的VirtualSpaceList链表的Node中分配内存是“昂贵”的操作，需要加锁。
    我们不希望这个操作太频繁，因此一次性给一个大的MetaChunk块，以便于这个类加载器之后加载其他的类，
 - 这样就可以做到多个类加载器并发分配了。只有当这个chunk块用完了，类加载器才需要VirtualSpaceList去申请新的chunk。


    2、chunk有三种规格，那么Metaspace的分配器是怎么知道一个类加载器每次要多大的chunk呢？
 - 通常，一个标准的类加载器在第一次申请空间时会得到一个4KB的chunk块，直到它达到了一个随意设
    置的阈值，此时分配器失去了耐心，会一次性分配一个64KB的chunk块。
 - bootstrap classloader是一个公认的会加载大量
    类的加载器，因此分配器会给它一个巨大的chunk，一开始就给它分配4MB。可以通过
    InitialBootClassLoaderMetaspaceSize进行调优。
 - 反射类类加载器和匿名类类加载器只会加载一个类，所以一开始只会
    给它们一个非常小的chunk块（1KB），因为给太多是一种浪费。